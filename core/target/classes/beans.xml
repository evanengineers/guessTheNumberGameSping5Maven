<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    <!-- default-init-method="reset"  using this insures that every bean it will automatically use the init meathed.. Could also use destroy methods in same way -->

   <!-- <context:annotation-config/> -->
    <context:component-scan base-package="evan.learningprogramming"/> <!--using this implicitly adds the annotation-config above. so its no longer needed.
    also, since components will be scanned for in the app classes, there is no need for all the beans below so we can comment out those as well. -->

    <!--<bean id="numberGenerator" class="evan.learningprogramming.NumberGeneratorImpl"/> -->

    <!-- The below bean would be used when doing a constructor based dependency injection.  Se GameIMPL class ex.
<bean id="game" class="evan.learningprogramming.GameImpl">
    <constructor-arg ref="numberGenerator"/>
</bean>
-->
    <!-- The below is an example of how to use setter based DI. instead of using constructor-arg, you will use property which is name of the field being set -->
    <!-- <bean id="game" class="evan.learningprogramming.GameImpl">
        <property name="numberGenerator" ref="numberGenerator"/> <the ref references the beanid. They must always match.
    </bean> -->

    <!-- using post-construct annotation
    <bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"/>
    -->
    <!--
    <bean id="game" class="evan.learningprogramming.GameImpl">

    </bean>-->


</beans>